import fs from 'fs';
import path from 'path';
import JSZip from 'jszip';
import { allVolumes } from './volumes';
import { getVolumeStructure, isStoryChapter } from './epub-parser';

async function getVolumeMappings(volumeId: string, epubSource: string): Promise<number[]> {
    const publicPath = path.join(process.cwd(), 'public', epubSource);

    if (!fs.existsSync(publicPath)) {
        console.warn(`  ‚ö†Ô∏è EPUB not found: ${publicPath}`);
        return [];
    }

    const buffer = fs.readFileSync(publicPath);
    const arrayBuffer = buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
    const zip = await JSZip.loadAsync(arrayBuffer);

   
    const structure = await getVolumeStructure(volumeId, zip);

    if (!structure) {
        console.warn(`  ‚ö†Ô∏è Failed to parse structure for ${volumeId}`);
        return [];
    }

    const toc = structure.toc;

  
   
    const storyChapters = toc.filter(t => isStoryChapter(t.label));

  
    const mappingCandidates = storyChapters.filter(t => !t.label.match(/^Part \d+/i));

    return mappingCandidates.map(t => t.index);
}

async function generateAllMappings() {
    console.log('üîç Generating chapter mappings for all volumes... (using epub-parser)\n');

    const mappings: Record<string, number[]> = {};

    for (const volume of allVolumes) {
        if (!volume.epubSource) {
            console.log(`  ‚è≠Ô∏è Skipping ${volume.id} (no EPUB source)`);
            continue;
        }

        console.log(`  üìñ Processing ${volume.id}...`);
        try {
            const indices = await getVolumeMappings(volume.id, volume.epubSource);

            if (indices.length > 0) {
                mappings[volume.id] = indices;
                console.log(`     ‚úÖ Found ${indices.length} chapters: [${indices.slice(0, 5).join(', ')}${indices.length > 5 ? '...' : ''}]`);
            } else {
                console.log(`     ‚ùå Found 0 chapters.`);
            }
        } catch (e) {
            console.error(`     ‚ùå Error processing ${volume.id}:`, e);
        }
    }

   
    const outputPath = path.join(process.cwd(), 'lib', 'chapter-mappings.ts');
    const content = `// Auto-generated by generate-mappings.ts
// Maps logical chapter index (0-based) to spine index
// Usage: chapterMappings["v1"][0] = spine index of Chapter 1

export const chapterMappings: Record<string, number[]> = ${JSON.stringify(mappings, null, 2)};

/**
 * Get the spine index for a logical chapter
 * @param volumeId - e.g., "v1"
 * @param logicalIndex - 0-based logical chapter index (Chapter 1 = 0)
 * @returns spine index, or logicalIndex + 1 if no mapping exists
 */
export function getSpineIndex(volumeId: string, logicalIndex: number): number {
    const mapping = chapterMappings[volumeId];
    if (mapping && mapping[logicalIndex]) {
        return mapping[logicalIndex];
    }
    return logicalIndex + 1; // Fallback to 1-based index
}
`;

    fs.writeFileSync(outputPath, content);
    console.log(`\n‚úÖ Generated ${outputPath}`);
    console.log(`   Total volumes mapped: ${Object.keys(mappings).length}`);
}

generateAllMappings().catch(console.error);
